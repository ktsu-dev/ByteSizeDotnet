<!-- Generated by SpecStory -->

# Building a dotnet self-study curriculum (2025-06-08 12:03:26)

_**User**_

I want to build a curriculum for teaching myself dotnet, with a focus on building libraries, tools, and games, I'm less interested in building web services for now.

I have about 2 hours per evening and I have ADHD so I need small approachable projects that have a clear single focus to teach me a concept and move on.

dont spemd much time on basic programming constructs like conditions, flow control, variables, types, methods etc. Im somewhat familiar with programming, I moreso want to know how those basic concepts are expressed in dotnet for that part, and learn the dotnet domain specific nomenclature for everything.

things like containers, async, extension methods, pattern matching, enumerables and deferred execution, linq, fluent apis, dependency injection, nuget, reflection, solid and dry principles etc. 

Make the concepts that the projects teach build upon each other in a sensible way, I dont nesscessarily need each project to be related to each other, infact it might be better if they are not related so that I can focus on the concept being taught and not the context of the project being created.

---

_**Assistant**_



---

I'll create a comprehensive curriculum for you that focuses on .NET-specific concepts while building practical libraries, tools, and games. Let me structure this as a progressive learning path with bite-sized projects.

---



---



---

Let me first check if the file exists and then create the curriculum structure:

---

<details>
            <summary>Listed directory curriculum ‚Ä¢ **1** results</summary>
        
| Name |
|-------|
| üìÑ `README.md` |

</details>

---

Let me read the existing file to see what's there:

---

Read file: curriculum/README.md

---

Perfect! The curriculum is already there. Let me read the rest and then create the first detailed project to get you started:

---

Read file: curriculum/README.md

---

Great! Your curriculum is already set up. Now let me create the detailed first project to get you started. Let me create the Week 1 project specification:

---

```diff
- 
+ # Week 1: Dice Rolling Library
+ 
+ **Focus**: .NET Type System & Conventions  
+ **Time**: ~2 hours  
+ **Deliverable**: `DiceRoller` NuGet package
+ 
+ ## Learning Objectives
+ 
+ By completing this project, you'll understand:
+ - .NET naming conventions (PascalCase, camelCase, etc.)
+ - Properties vs fields vs methods
+ - Value types (`struct`) vs reference types (`class`)
+ - When to use `var` vs explicit typing
+ - Basic .NET project structure
+ - Essential C# idioms
+ 
+ ## Project Overview
+ 
+ Build a dice rolling library that game developers can use. This seems simple, but you'll learn fundamental .NET concepts while creating something genuinely useful.
+ 
+ ## What You'll Build
+ 
+ A library that can:
+ - Roll various dice types (d4, d6, d8, d10, d12, d20, d100)
+ - Roll multiple dice at once (`3d6`, `2d20`, etc.)
+ - Apply modifiers (`1d20+5`, `3d6-2`)
+ - Parse dice notation strings (`"2d6+3"`)
+ - Provide roll statistics and history
+ 
+ ## Core Concepts to Learn
+ 
+ ### .NET Naming Conventions
+ - **Classes/Interfaces**: `PascalCase` (`DiceRoller`, `IDice`)
+ - **Methods/Properties**: `PascalCase` (`Roll()`, `LastResult`)
+ - **Parameters/Variables**: `camelCase` (`diceCount`, `modifier`)
+ - **Constants**: `PascalCase` (`MaxSides`)
+ - **Private fields**: `_camelCase` (`_random`, `_history`)
+ 
+ ### Value Types vs Reference Types
+ - Use `struct` for `DiceResult` (small, immutable data)
+ - Use `class` for `DiceRoller` (behavior, mutable state)
+ 
+ ### Properties vs Fields
+ - Expose data through properties, not public fields
+ - Use auto-properties where appropriate
+ - Understand when to use full properties with backing fields
+ 
+ ## Implementation Guide
+ 
+ ### Step 1: Project Setup (15 minutes)
+ ```bash
+ # Create new class library project
+ dotnet new classlib -n DiceRoller
+ cd DiceRoller
+ 
+ # Update to latest C# version in .csproj
+ <TargetFramework>net8.0</TargetFramework>
+ <LangVersion>latest</LangVersion>
+ ```
+ 
+ ### Step 2: Core Types (30 minutes)
+ 
+ Create your fundamental types:
+ 
+ **`DiceResult` (struct)**
+ ```csharp
+ // Value type - represents the result of a dice roll
+ public readonly struct DiceResult
+ {
+     public int Value { get; }
+     public int[] IndividualRolls { get; }
+     public int Modifier { get; }
+     
+     // Constructor, ToString(), equality methods
+ }
+ ```
+ 
+ **`Die` (struct)**
+ ```csharp
+ // Value type - represents a single die
+ public readonly struct Die
+ {
+     public int Sides { get; }
+     // Methods: Roll(), IsValid(), common dice (D6, D20, etc.)
+ }
+ ```
+ 
+ ### Step 3: Main DiceRoller Class (45 minutes)
+ 
+ **`DiceRoller` (class)**
+ ```csharp
+ public class DiceRoller
+ {
+     private readonly Random _random;  // backing field
+     private readonly List<DiceResult> _history;  // backing field
+     
+     public IReadOnlyList<DiceResult> History => _history;  // property
+     public DiceResult LastResult => _history.LastOrDefault();  // computed property
+     
+     // Methods: Roll(), RollMultiple(), ParseAndRoll()
+ }
+ ```
+ 
+ ### Step 4: Dice Notation Parser (30 minutes)
+ 
+ Add ability to parse strings like `"3d6+2"`, `"1d20"`, `"2d10-1"`:
+ 
+ ```csharp
+ public static class DiceNotation
+ {
+     public static (int count, int sides, int modifier) Parse(string notation)
+     {
+         // Parse "3d6+2" into (3, 6, 2)
+         // Handle edge cases and validation
+     }
+ }
+ ```
+ 
+ ### Step 5: Extension Methods Preview (20 minutes)
+ 
+ Get a taste of extension methods (covered fully in Week 3):
+ 
+ ```csharp
+ public static class IntExtensions
+ {
+     public static Die D(this int sides) => new Die(sides);
+     public static DiceResult Roll(this int count, Die die) => /* ... */;
+ }
+ 
+ // Usage: 6.D().Roll() or 3.Roll(20.D())
+ ```
+ 
+ ## Key .NET Idioms to Practice
+ 
+ 1. **Property Patterns**:
+    ```csharp
+    // Auto-property
+    public int Sides { get; }
+    
+    // Computed property
+    public bool IsValid => Sides > 0;
+    
+    // Property with backing field
+    private int _lastRoll;
+    public int LastRoll => _lastRoll;
+    ```
+ 
+ 2. **Constructor Patterns**:
+    ```csharp
+    // Primary constructor (C# 12+)
+    public Die(int sides)
+    {
+        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(sides);
+        Sides = sides;
+    }
+    ```
+ 
+ 3. **Null Safety**:
+    ```csharp
+    public DiceResult? LastResult => _history.Count > 0 ? _history[^1] : null;
+    ```
+ 
+ 4. **String Interpolation**:
+    ```csharp
+    public override string ToString() => $"{Count}d{Sides}{(Modifier >= 0 ? "+" : "")}{Modifier}";
+    ```
+ 
+ ## Testing Your Understanding
+ 
+ Create a simple console app to test your library:
+ 
+ ```csharp
+ var roller = new DiceRoller();
+ 
+ // Test different ways to roll
+ var result1 = roller.Roll(new Die(6));
+ var result2 = roller.Roll(3, new Die(6), modifier: 2);
+ var result3 = roller.ParseAndRoll("2d20+5");
+ 
+ Console.WriteLine($"Single d6: {result1}");
+ Console.WriteLine($"3d6+2: {result2}");
+ Console.WriteLine($"Parsed 2d20+5: {result3}");
+ Console.WriteLine($"Roll history: {roller.History.Count} rolls");
+ ```
+ 
+ ## Extension Challenges
+ 
+ If you finish early or want to explore more:
+ 
+ 1. **Add Advantage/Disadvantage**: Roll twice, take highest/lowest
+ 2. **Dice Pools**: Roll multiple dice, count successes above threshold  
+ 3. **Custom Dice**: Support non-standard dice (d3, d7, etc.)
+ 4. **Roll Statistics**: Track averages, streaks, probability distributions
+ 5. **Serialization**: Save/load roll history to JSON
+ 
+ ## Common Pitfalls & Solutions
+ 
+ 1. **Using `class` for `DiceResult`**: Should be `struct` - it's small, immutable data
+ 2. **Public fields**: Use properties instead for better encapsulation
+ 3. **Missing validation**: Always validate constructor parameters
+ 4. **Inconsistent naming**: Follow .NET conventions religiously
+ 5. **Mutable structs**: Keep structs readonly when possible
+ 
+ ## Success Criteria
+ 
+ ‚úÖ Created a working dice rolling library  
+ ‚úÖ Used `struct` for value types, `class` for reference types  
+ ‚úÖ Followed .NET naming conventions throughout  
+ ‚úÖ Implemented properties correctly (auto, computed, backing field)  
+ ‚úÖ Added proper parameter validation  
+ ‚úÖ Created a simple test console application  
+ ‚úÖ Library feels "natural" to use (good API design)
+ 
+ ## Next Week Preview
+ 
+ In Week 2, you'll learn about collections and `IEnumerable<T>` by building a card deck shuffler. Your dice library will remain standalone, but the concepts will build on what you learned about types and properties.
+ 
+ ## Further Reading
+ 
+ - [C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
+ - [Choosing Between Class and Struct](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)
+ - [Properties in C#](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties)
+ 
+ ---
+ 
+ **Ready to start? Create your project and begin with Step 1!** üé≤ 
```

---

Now let me create a quick reference guide for the key concepts to help you while working:

---

```diff
- 
+ # .NET Quick Reference Guide
+ 
+ *Handy reference for concepts covered in this curriculum*
+ 
+ ## üìù Naming Conventions
+ 
+ | Element | Convention | Example |
+ |---------|------------|---------|
+ | Classes, Interfaces, Methods, Properties | `PascalCase` | `DiceRoller`, `IDice`, `Roll()`, `LastResult` |
+ | Parameters, Local Variables | `camelCase` | `diceCount`, `modifier`, `result` |
+ | Private Fields | `_camelCase` | `_random`, `_history`, `_lastRoll` |
+ | Constants | `PascalCase` | `MaxSides`, `DefaultCount` |
+ | Namespaces | `PascalCase` | `MyCompany.GameLibraries` |
+ 
+ ## üèóÔ∏è Type System Quick Decisions
+ 
+ ### When to use `struct` vs `class`?
+ 
+ **Use `struct` when:**
+ - Small data (< 16 bytes typically)
+ - Immutable (readonly)
+ - Value semantics (copying makes sense)
+ - No inheritance needed
+ - Examples: `Point`, `Color`, `DiceResult`
+ 
+ **Use `class` when:**
+ - Mutable state
+ - Reference semantics (sharing makes sense)
+ - Inheritance needed
+ - Complex behavior
+ - Examples: `DiceRoller`, `GameEngine`, `Player`
+ 
+ ### Properties vs Fields vs Methods
+ 
+ ```csharp
+ // ‚ùå Public field - avoid
+ public int Value;
+ 
+ // ‚úÖ Auto-property - simple data
+ public int Value { get; set; }
+ public int Value { get; } // readonly
+ 
+ // ‚úÖ Computed property - derived data
+ public bool IsEven => Value % 2 == 0;
+ 
+ // ‚úÖ Property with backing field - validation/logic
+ private int _value;
+ public int Value 
+ { 
+     get => _value; 
+     set => _value = value < 0 ? 0 : value; 
+ }
+ 
+ // ‚úÖ Method - actions or complex operations
+ public int CalculateTotal() => /* complex logic */;
+ ```
+ 
+ ## üîß Common Patterns
+ 
+ ### Constructor Validation
+ ```csharp
+ public Die(int sides)
+ {
+     ArgumentOutOfRangeException.ThrowIfNegativeOrZero(sides);
+     Sides = sides;
+ }
+ ```
+ 
+ ### Null Safety
+ ```csharp
+ // Nullable reference types
+ public string? Name { get; set; }
+ 
+ // Null-conditional operators
+ var length = name?.Length ?? 0;
+ var first = collection?.FirstOrDefault();
+ 
+ // Null-coalescing assignment
+ name ??= "Default";
+ ```
+ 
+ ### String Interpolation
+ ```csharp
+ // ‚úÖ Preferred
+ var message = $"Rolled {count}d{sides} = {total}";
+ 
+ // ‚ùå Avoid
+ var message = "Rolled " + count + "d" + sides + " = " + total;
+ ```
+ 
+ ## üìö Collections Cheat Sheet
+ 
+ ```csharp
+ // Arrays - fixed size
+ int[] numbers = new int[5];
+ int[] values = { 1, 2, 3, 4, 5 };
+ 
+ // Lists - dynamic size
+ var list = new List<int> { 1, 2, 3 };
+ list.Add(4);
+ 
+ // Dictionaries - key-value pairs
+ var dict = new Dictionary<string, int>
+ {
+     ["one"] = 1,
+     ["two"] = 2
+ };
+ 
+ // Read-only collections - expose internal collections safely
+ private readonly List<int> _values = new();
+ public IReadOnlyList<int> Values => _values;
+ ```
+ 
+ ## üîÑ LINQ Quick Reference
+ 
+ ```csharp
+ var numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
+ 
+ // Filtering
+ var evens = numbers.Where(n => n % 2 == 0);
+ 
+ // Transformation
+ var doubled = numbers.Select(n => n * 2);
+ 
+ // Aggregation
+ var sum = numbers.Sum();
+ var max = numbers.Max();
+ var average = numbers.Average();
+ 
+ // Combination
+ var evenDoubled = numbers
+     .Where(n => n % 2 == 0)
+     .Select(n => n * 2)
+     .ToList(); // Execute immediately
+ 
+ // Grouping
+ var byRemainder = numbers.GroupBy(n => n % 3);
+ ```
+ 
+ ## ‚ö° Async/Await Essentials
+ 
+ ```csharp
+ // Async method signature
+ public async Task<string> LoadDataAsync()
+ {
+     // Await other async operations
+     var data = await File.ReadAllTextAsync("file.txt");
+     return data.ToUpper();
+ }
+ 
+ // Calling async methods
+ var result = await LoadDataAsync();
+ 
+ // Multiple async operations
+ var task1 = LoadDataAsync();
+ var task2 = LoadOtherDataAsync();
+ await Task.WhenAll(task1, task2);
+ 
+ // ConfigureAwait(false) in libraries
+ var data = await File.ReadAllTextAsync("file.txt").ConfigureAwait(false);
+ ```
+ 
+ ## üéØ Extension Methods
+ 
+ ```csharp
+ // Extension method definition
+ public static class StringExtensions
+ {
+     public static bool IsNullOrWhiteSpace(this string? value)
+     {
+         return string.IsNullOrWhiteSpace(value);
+     }
+     
+     public static string Repeat(this string value, int count)
+     {
+         return string.Concat(Enumerable.Repeat(value, count));
+     }
+ }
+ 
+ // Usage
+ "hello".IsNullOrWhiteSpace(); // false
+ "*".Repeat(5); // "*****"
+ ```
+ 
+ ## üèõÔ∏è SOLID Principles Quick Check
+ 
+ **S** - Single Responsibility: One reason to change  
+ **O** - Open/Closed: Open for extension, closed for modification  
+ **L** - Liskov Substitution: Derived classes must be substitutable  
+ **I** - Interface Segregation: Many specific interfaces > one general  
+ **D** - Dependency Inversion: Depend on abstractions, not concretions  
+ 
+ ## üß™ Testing Patterns
+ 
+ ```csharp
+ [Fact]
+ public void DiceRoller_Roll_ShouldReturnValidResult()
+ {
+     // Arrange
+     var roller = new DiceRoller();
+     var die = new Die(6);
+     
+     // Act
+     var result = roller.Roll(die);
+     
+     // Assert
+     Assert.InRange(result.Value, 1, 6);
+ }
+ 
+ // Mocking with Moq
+ var mockService = new Mock<IGameService>();
+ mockService.Setup(s => s.GetPlayer(It.IsAny<int>()))
+            .Returns(new Player { Name = "Test" });
+ ```
+ 
+ ## üé® Fluent API Design
+ 
+ ```csharp
+ // Method chaining
+ var query = builder
+     .Where(x => x.IsActive)
+     .OrderBy(x => x.Name)
+     .Select(x => x.DisplayName)
+     .Build();
+ 
+ // Builder pattern
+ var config = new GameConfigBuilder()
+     .WithPlayer("Alice")
+     .WithDifficulty(Difficulty.Hard)
+     .WithRules(rules => rules
+         .AllowSaveStates()
+         .EnableCheats(false))
+     .Build();
+ ```
+ 
+ ---
+ 
+ *Keep this handy while working through the projects!* üìñ 
```

---

Perfect! I've created a comprehensive .NET learning curriculum tailored specifically for your needs. Here's what I've built for you:

## üéØ Your .NET Curriculum Overview

**üìã Main Curriculum (`curriculum/README.md`)**
- **20 weeks** of focused, 2-hour projects
- **5 phases** that progressively build your .NET expertise
- **ADHD-friendly**: Each project has a single, clear focus
- **Game/Tool-focused**: No web services, all practical libraries and games
- **Independent projects**: No complex dependencies between projects

**üìñ Week 1 Detailed Project (`curriculum/week-01-dice-roller/README.md`)**
- Complete specification for your first project: Dice Rolling Library
- Step-by-step implementation guide with time estimates
- Focuses on .NET type system, naming conventions, and basic idioms
- Includes extension challenges if you finish early

**üìö Quick Reference Guide (`curriculum/quick-reference.md`)**
- Handy reference for all the concepts you'll learn
- Quick decision guides (struct vs class, when to use what)
- Code patterns and examples you can copy/adapt
- Keep this open while coding!

## üöÄ Key Features of This Curriculum

‚úÖ **Perfect for ADHD**: Small, focused sessions with clear deliverables  
‚úÖ **Builds Progressively**: Each concept logically builds on previous ones  
‚úÖ **Practical Focus**: Libraries, tools, and games - no theoretical fluff  
‚úÖ **Modern .NET**: Uses latest C# features and best practices  
‚úÖ **Independent Projects**: Focus on concepts, not complex project relationships  

## üìã The Learning Path

1. **Phase 1 (Weeks 1-4)**: .NET fundamentals and idioms
2. **Phase 2 (Weeks 5-8)**: Advanced language features (LINQ, async, generics)
3. **Phase 3 (Weeks 9-12)**: Architecture and design patterns
4. **Phase 4 (Weeks 13-16)**: Advanced .NET features (reflection, performance)
5. **Phase 5 (Weeks 17-20)**: Tooling and distribution (NuGet, testing)

## üéÆ Sample Projects You'll Build

- **Dice Rolling Library** (Week 1) - Learn type system
- **Card Deck Shuffler** (Week 2) - Master collections  
- **State Machine for Games** (Week 4) - Pattern matching
- **Game Statistics Analyzer** (Week 5) - LINQ mastery
- **Plugin System** (Week 9) - Dependency injection
- **Procedural Dungeon Generator** (Week 10) - Design patterns

## üéØ Ready to Start?

You're all set to begin with **Week 1: Dice Rolling Library**! The project is fully specified and should take about 2 hours. You'll learn:

- .NET naming conventions
- `struct` vs `class` decisions  
- Properties vs fields
- Basic C# idioms
- Project structure

**Next step**: Open `curriculum/week-01-dice-roller/README.md` and follow Step 1 to create your first project!

This curriculum will take you from .NET fundamentals to advanced concepts while building a portfolio of useful libraries and tools. Each project stands alone, so you can focus purely on learning the concept being taught.

---

_**User**_

continue creating the curriculum pages

---

_**Assistant**_



---

I'll continue creating the detailed project specifications for the remaining weeks. Let me create Week 2 through Week 4 to complete Phase 1, and then start on Phase 2.

---

```diff
- 
+ # Week 2: Card Deck Shuffler
+ 
+ **Focus**: Collections & Enumerables  
+ **Time**: ~2 hours  
+ **Deliverable**: Card game foundation library
+ 
+ ## Learning Objectives
+ 
+ By completing this project, you'll understand:
+ - Generic collections (`List<T>`, `IEnumerable<T>`, `ICollection<T>`)
+ - How `foreach` works under the hood
+ - Difference between `IEnumerable<T>` and concrete collections
+ - Collection initializers and modern syntax
+ - When to use arrays vs lists vs other collections
+ - Implementing `IEnumerable<T>` yourself
+ 
+ ## Project Overview
+ 
+ Build a comprehensive card deck library that any card game can use. You'll learn .NET's collection system by modeling a real-world domain that's inherently collection-heavy.
+ 
+ ## What You'll Build
+ 
+ A library that can:
+ - Create standard 52-card decks with suits and ranks
+ - Shuffle decks using different algorithms
+ - Deal cards from the deck
+ - Support different deck types (Poker, Blackjack, UNO, etc.)
+ - Track dealt vs remaining cards
+ - Restore dealt cards back to deck
+ 
+ ## Core Concepts to Learn
+ 
+ ### Collections Hierarchy
+ ```
+ IEnumerable<T>        // Can iterate (foreach)
+ ‚îî‚îÄ‚îÄ ICollection<T>    // Can add/remove/count
+     ‚îî‚îÄ‚îÄ IList<T>      // Can index and insert
+         ‚îî‚îÄ‚îÄ List<T>   // Concrete implementation
+ ```
+ 
+ ### Generic Collections
+ - `List<T>` - Most common, dynamic array
+ - `IEnumerable<T>` - For iteration and LINQ
+ - `IReadOnlyList<T>` - Expose lists safely
+ - `Queue<T>` and `Stack<T>` - Specialized ordering
+ 
+ ## Implementation Guide
+ 
+ ### Step 1: Project Setup (10 minutes)
+ ```bash
+ # Create new class library project
+ dotnet new classlib -n CardDeck
+ cd CardDeck
+ ```
+ 
+ ### Step 2: Core Card Types (25 minutes)
+ 
+ **Card Enums and Structs**
+ ```csharp
+ public enum Suit
+ {
+     Hearts,   // ‚ô•
+     Diamonds, // ‚ô¶
+     Clubs,    // ‚ô£
+     Spades    // ‚ô†
+ }
+ 
+ public enum Rank
+ {
+     Two = 2, Three, Four, Five, Six, Seven, Eight, 
+     Nine, Ten, Jack, Queen, King, Ace
+ }
+ 
+ public readonly struct Card : IEquatable<Card>
+ {
+     public Suit Suit { get; }
+     public Rank Rank { get; }
+     
+     public Card(Suit suit, Rank rank)
+     {
+         Suit = suit;
+         Rank = rank;
+     }
+     
+     // IEquatable, ToString, GetHashCode
+     public override string ToString() => $"{Rank} of {Suit}";
+ }
+ ```
+ 
+ ### Step 3: Deck as IEnumerable (30 minutes)
+ 
+ **Understanding IEnumerable<T>**
+ ```csharp
+ public class Deck : IEnumerable<Card>
+ {
+     private readonly List<Card> _cards;
+     private readonly List<Card> _dealtCards;
+     
+     public int Count => _cards.Count;
+     public int DealtCount => _dealtCards.Count;
+     public bool IsEmpty => _cards.Count == 0;
+     
+     // Factory methods
+     public static Deck CreateStandard52() => /* ... */;
+     public static Deck CreateBlackjackDeck() => /* ... */;
+     
+     // IEnumerable implementation
+     public IEnumerator<Card> GetEnumerator() => _cards.GetEnumerator();
+     IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+ }
+ ```
+ 
+ **Key Learning: Why implement IEnumerable?**
+ - Enables `foreach` loops: `foreach (var card in deck)`
+ - Enables LINQ: `deck.Where(c => c.Suit == Suit.Hearts)`
+ - Makes your type feel "native" to .NET
+ 
+ ### Step 4: Collection Operations (35 minutes)
+ 
+ **Shuffling with Different Algorithms**
+ ```csharp
+ public class Deck : IEnumerable<Card>
+ {
+     private readonly Random _random;
+     
+     public void Shuffle(ShuffleAlgorithm algorithm = ShuffleAlgorithm.FisherYates)
+     {
+         switch (algorithm)
+         {
+             case ShuffleAlgorithm.FisherYates:
+                 FisherYatesShuffle();
+                 break;
+             case ShuffleAlgorithm.Riffle:
+                 RiffleShuffle();
+                 break;
+         }
+     }
+     
+     private void FisherYatesShuffle()
+     {
+         // Learn: Modern shuffle algorithm
+         for (int i = _cards.Count - 1; i > 0; i--)
+         {
+             int j = _random.Next(i + 1);
+             (_cards[i], _cards[j]) = (_cards[j], _cards[i]); // Tuple swap!
+         }
+     }
+     
+     // Deal methods
+     public Card Deal()
+     {
+         if (IsEmpty) throw new InvalidOperationException("Cannot deal from empty deck");
+         
+         var card = _cards[^1]; // Index from end operator
+         _cards.RemoveAt(_cards.Count - 1);
+         _dealtCards.Add(card);
+         return card;
+     }
+     
+     public IEnumerable<Card> Deal(int count)
+     {
+         // Learn: yield return for custom iterators
+         for (int i = 0; i < count; i++)
+         {
+             yield return Deal();
+         }
+     }
+ }
+ ```
+ 
+ ### Step 5: Collection Initialization & LINQ Preview (20 minutes)
+ 
+ **Modern Collection Syntax**
+ ```csharp
+ public static class DeckBuilder
+ {
+     // Collection expressions (C# 12+)
+     public static Deck CreateCustom(IEnumerable<Card> cards) => new(cards);
+     
+     // Target-typed new
+     public static Dictionary<Suit, List<Card>> GroupBySuit(Deck deck)
+     {
+         return new()
+         {
+             [Suit.Hearts] = deck.Where(c => c.Suit == Suit.Hearts).ToList(),
+             [Suit.Diamonds] = deck.Where(c => c.Suit == Suit.Diamonds).ToList(),
+             [Suit.Clubs] = deck.Where(c => c.Suit == Suit.Clubs).ToList(),
+             [Suit.Spades] = deck.Where(c => c.Suit == Suit.Spades).ToList(),
+         };
+     }
+     
+     // Extension method preview (more in Week 3)
+     public static Deck Shuffle(this Deck deck)
+     {
+         deck.Shuffle();
+         return deck; // Fluent interface
+     }
+ }
+ ```
+ 
+ ## Key .NET Collection Patterns
+ 
+ ### 1. Choosing the Right Collection
+ ```csharp
+ // ‚úÖ Use List<T> for most scenarios
+ private readonly List<Card> _cards = new();
+ 
+ // ‚úÖ Expose as IReadOnlyList<T> for safety
+ public IReadOnlyList<Card> Cards => _cards;
+ 
+ // ‚úÖ Use IEnumerable<T> for parameters (most flexible)
+ public void AddCards(IEnumerable<Card> cards) => _cards.AddRange(cards);
+ 
+ // ‚ùå Don't expose List<T> directly
+ public List<Card> Cards => _cards; // Allows external modification!
+ ```
+ 
+ ### 2. Collection Initialization
+ ```csharp
+ // Modern way
+ var suits = new List<Suit> { Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades };
+ 
+ // Dictionary initialization
+ var cardValues = new Dictionary<Rank, int>
+ {
+     [Rank.Ace] = 1,
+     [Rank.King] = 13,
+     [Rank.Queen] = 12,
+     [Rank.Jack] = 11
+ };
+ ```
+ 
+ ### 3. Safe Iteration
+ ```csharp
+ // ‚úÖ Safe: Won't break if collection is modified
+ public IEnumerable<Card> GetRedCards()
+ {
+     return _cards.Where(c => c.Suit is Suit.Hearts or Suit.Diamonds);
+ }
+ 
+ // ‚ùå Dangerous: Direct exposure
+ public List<Card> GetRedCards()
+ {
+     return _cards.Where(c => c.Suit is Suit.Hearts or Suit.Diamonds).ToList();
+ }
+ ```
+ 
+ ## Testing Your Understanding
+ 
+ Create a console app to test your library:
+ 
+ ```csharp
+ var deck = Deck.CreateStandard52();
+ Console.WriteLine($"Created deck with {deck.Count} cards");
+ 
+ // Test enumeration
+ foreach (var card in deck.Take(5))
+ {
+     Console.WriteLine(card);
+ }
+ 
+ // Test shuffling and dealing
+ deck.Shuffle();
+ var hand = deck.Deal(5).ToList();
+ Console.WriteLine($"Dealt hand: {string.Join(", ", hand)}");
+ Console.WriteLine($"Remaining cards: {deck.Count}");
+ 
+ // Test LINQ operations
+ var redCards = deck.Where(c => c.Suit is Suit.Hearts or Suit.Diamonds);
+ Console.WriteLine($"Red cards remaining: {redCards.Count()}");
+ ```
+ 
+ ## Extension Challenges
+ 
+ 1. **Multiple Deck Types**: Support UNO cards, Tarot decks, custom card sets
+ 2. **Hand Evaluation**: Add poker hand ranking (pair, flush, etc.)
+ 3. **Deck Statistics**: Track shuffling patterns, deal history
+ 4. **Custom Iterators**: Implement different dealing patterns (alternating, by suit)
+ 5. **Performance**: Benchmark different shuffling algorithms
+ 
+ ## Common Collection Pitfalls
+ 
+ 1. **Modifying during iteration**: 
+    ```csharp
+    // ‚ùå Will throw exception
+    foreach (var card in deck)
+    {
+        if (card.Rank == Rank.Ace)
+            deck.RemoveCard(card); // Modifies collection!
+    }
+    
+    // ‚úÖ Use ToList() to create snapshot
+    foreach (var card in deck.ToList())
+    {
+        if (card.Rank == Rank.Ace)
+            deck.RemoveCard(card);
+    }
+    ```
+ 
+ 2. **Multiple enumeration**:
+    ```csharp
+    var redCards = deck.Where(c => c.Suit is Suit.Hearts or Suit.Diamonds);
+    Console.WriteLine(redCards.Count()); // Enumerates once
+    Console.WriteLine(redCards.First()); // Enumerates again!
+    
+    // ‚úÖ Materialize once
+    var redCardsList = deck.Where(c => c.Suit is Suit.Hearts or Suit.Diamonds).ToList();
+    ```
+ 
+ 3. **Null in collections**:
+    ```csharp
+    // ‚úÖ Prevent nulls at the boundary
+    public void AddCards(IEnumerable<Card> cards)
+    {
+        ArgumentNullException.ThrowIfNull(cards);
+        foreach (var card in cards)
+        {
+            ArgumentNullException.ThrowIfNull(card);
+            _cards.Add(card);
+        }
+    }
+    ```
+ 
+ ## Success Criteria
+ 
+ ‚úÖ Created a working card deck library  
+ ‚úÖ Implemented `IEnumerable<Card>` correctly  
+ ‚úÖ Used appropriate collection types (`List<T>`, `IReadOnlyList<T>`)  
+ ‚úÖ Demonstrated understanding of `foreach` mechanics  
+ ‚úÖ Implemented multiple shuffling algorithms  
+ ‚úÖ Used modern C# collection syntax  
+ ‚úÖ Applied LINQ operations effectively  
+ ‚úÖ Created safe collection exposure patterns
+ 
+ ## Next Week Preview
+ 
+ Week 3 will teach extension methods and fluent APIs by building string processing utilities. You'll learn how to "extend" existing types like `string` with your own methods, making APIs that feel natural and chainable.
+ 
+ ## Further Reading
+ 
+ - [Collections in .NET](https://docs.microsoft.com/en-us/dotnet/standard/collections/)
+ - [IEnumerable Interface](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1)
+ - [yield keyword](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield)
+ 
+ ---
+ 
+ **Ready to shuffle some cards? Begin with Step 1!** üÉè 
```

---

```diff
- 
+ # Week 3: String Processing Utilities
+ 
+ **Focus**: Extension Methods & Fluent APIs  
+ **Time**: ~2 hours  
+ **Deliverable**: Text manipulation library with fluent API
+ 
+ ## Learning Objectives
+ 
+ By completing this project, you'll understand:
+ - How extension methods work (`this` parameter)
+ - Creating fluent interfaces and method chaining
+ - When and why to use extension methods
+ - Extending existing .NET types like `string`
+ - Building discoverable APIs that feel "native"
+ - Method chaining patterns and immutability
+ 
+ ## Project Overview
+ 
+ Build a string processing library that extends `string` with game development utilities like text formatting, color codes, template processing, and validation. You'll learn to make APIs that feel like they belong in .NET itself.
+ 
+ ## What You'll Build
+ 
+ A library that extends `string` with:
+ - Text formatting (padding, alignment, truncation)
+ - Color and markup processing (for game UIs)
+ - Template string processing (`"Hello {name}"`)
+ - Validation utilities (email, game tags, etc.)
+ - Text generation (random names, lorem ipsum)
+ - All chainable with fluent syntax
+ 
+ ## Core Concepts to Learn
+ 
+ ### Extension Methods
+ ```csharp
+ // This method "extends" string
+ public static string Reverse(this string input)
+ {
+     // Can be called as: "hello".Reverse()
+ }
+ ```
+ 
+ ### Fluent Interface Design
+ ```csharp
+ // Method chaining for readable APIs
+ var result = "  hello world  "
+     .Trim()
+     .ToTitleCase()
+     .Truncate(10)
+     .WithColor("#FF0000");
+ ```
+ 
+ ## Implementation Guide
+ 
+ ### Step 1: Project Setup (10 minutes)
+ ```bash
+ # Create new class library project
+ dotnet new classlib -n StringUtilities
+ cd StringUtilities
+ ```
+ 
+ ### Step 2: Basic Extension Methods (30 minutes)
+ 
+ **Core String Extensions**
+ ```csharp
+ public static class StringExtensions
+ {
+     // Simple extension method
+     public static string Reverse(this string input)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         return new string(input.ToCharArray().Reverse().ToArray());
+     }
+     
+     // Extension with parameters
+     public static string Truncate(this string input, int maxLength, string suffix = "...")
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         ArgumentOutOfRangeException.ThrowIfNegative(maxLength);
+         
+         if (input.Length <= maxLength) return input;
+         
+         var truncated = input[..Math.Max(0, maxLength - suffix.Length)];
+         return truncated + suffix;
+     }
+     
+     // Extension that returns same type (for chaining)
+     public static string ToTitleCase(this string input)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         if (string.IsNullOrWhiteSpace(input)) return input;
+         
+         return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(input.ToLower());
+     }
+ }
+ ```
+ 
+ ### Step 3: Fluent Interface Pattern (40 minutes)
+ 
+ **Text Formatting Builder**
+ ```csharp
+ // Immutable fluent interface
+ public static class StringFormatExtensions
+ {
+     public static string PadCenter(this string input, int totalWidth, char padChar = ' ')
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         if (input.Length >= totalWidth) return input;
+         
+         int padding = totalWidth - input.Length;
+         int leftPad = padding / 2;
+         int rightPad = padding - leftPad;
+         
+         return new string(padChar, leftPad) + input + new string(padChar, rightPad);
+     }
+     
+     public static string WithPrefix(this string input, string prefix)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         ArgumentNullException.ThrowIfNull(prefix);
+         return prefix + input;
+     }
+     
+     public static string WithSuffix(this string input, string suffix)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         ArgumentNullException.ThrowIfNull(suffix);
+         return input + suffix;
+     }
+     
+     // Chaining example usage:
+     // var formatted = "Hello"
+     //     .ToTitleCase()
+     //     .PadCenter(20, '-')
+     //     .WithPrefix("[")
+     //     .WithSuffix("]");
+ }
+ ```
+ 
+ **Game-Specific Extensions**
+ ```csharp
+ public static class GameStringExtensions
+ {
+     // Color markup for game UIs
+     public static string WithColor(this string input, string hexColor)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         ArgumentNullException.ThrowIfNull(hexColor);
+         return $"<color={hexColor}>{input}</color>";
+     }
+     
+     public static string Bold(this string input)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         return $"<b>{input}</b>";
+     }
+     
+     public static string Italic(this string input)
+     {
+         ArgumentNullException.ThrowIfNull(input);
+         return $"<i>{input}</i>";
+     }
+     
+     // Chaining: "Critical Hit!".Bold().WithColor("#FF0000")
+ }
+ ```
+ 
+ ### Step 4: Template Processing (30 minutes)
+ 
+ **Simple Template Engine**
+ ```csharp
+ public static class TemplateExtensions
+ {
+     // Process templates like "Hello {name}, you have {score} points"
+     public static string Process(this string template, object data)
+     {
+         ArgumentNullException.ThrowIfNull(template);
+         ArgumentNullException.ThrowIfNull(data);
+         
+         var result = template;
+         var properties = data.GetType().GetProperties();
+         
+         foreach (var prop in properties)
+         {
+             var placeholder = $"{{{prop.Name}}}";
+             var value = prop.GetValue(data)?.ToString() ?? "";
+             result = result.Replace(placeholder, value, StringComparison.OrdinalIgnoreCase);
+         }
+         
+         return result;
+     }
+     
+     // Dictionary-based processing
+     public static string Process(this string template, IDictionary<string, object> values)
+     {
+         ArgumentNullException.ThrowIfNull(template);
+         ArgumentNullException.ThrowIfNull(values);
+         
+         var result = template;
+         foreach (var kvp in values)
+         {
+             var placeholder = $"{{{kvp.Key}}}";
+             var value = kvp.Value?.ToString() ?? "";
+             result = result.Replace(placeholder, value, StringComparison.OrdinalIgnoreCase);
+         }
+         
+         return result;
+     }
+ }
+ 
+ // Usage:
+ // var message = "Hello {Name}, your level is {Level}!".Process(new { Name = "Alice", Level = 5 });
+ ```
+ 
+ ### Step 5: Validation Extensions (30 minutes)
+ 
+ **Fluent Validation Patterns**
+ ```csharp
+ public static class ValidationExtensions
+ {
+     public static bool IsValidEmail(this string input)
+     {
+         if (string.IsNullOrWhiteSpace(input)) return false;
+         
+         try
+         {
+             var addr = new System.Net.Mail.MailAddress(input);
+             return addr.Address == input;
+         }
+         catch
+         {
+             return false;
+         }
+     }
+     
+     public static bool IsValidGameTag(this string input)
+     {
+         // Game tags: alphanumeric, 3-16 chars, no spaces
+         if (string.IsNullOrWhiteSpace(input)) return false;
+         return Regex.IsMatch(input, @"^[a-zA-Z0-9]{3,16}$");
+     }
+     
+     public static bool HasMinLength(this string input, int minLength)
+     {
+         return input?.Length >= minLength;
+     }
+     
+     public static bool HasMaxLength(this string input, int maxLength)
+     {
+         return input?.Length <= maxLength;
+     }
+     
+     // Chaining validation:
+     // bool isValid = userInput
+     //     .HasMinLength(3)
+     //     && userInput.HasMaxLength(20)
+     //     && userInput.IsValidGameTag();
+ }
+ ```
+ 
+ ## Key Extension Method Patterns
+ 
+ ### 1. Null Safety First
+ ```csharp
+ public static string SafeMethod(this string input, string parameter)
+ {
+     ArgumentNullException.ThrowIfNull(input);      // Check 'this' parameter
+     ArgumentNullException.ThrowIfNull(parameter);  // Check other parameters
+     
+     // Your logic here
+     return result;
+ }
+ ```
+ 
+ ### 2. Immutable Chaining
+ ```csharp
+ // ‚úÖ Return new strings (immutable)
+ public static string Transform(this string input)
+ {
+     return input + "transformed"; // New string
+ }
+ 
+ // ‚ùå Don't modify the original (strings are immutable anyway)
+ // But this pattern applies to mutable types too
+ ```
+ 
+ ### 3. Logical Grouping
+ ```csharp
+ // Group related extensions in focused classes
+ public static class StringFormatExtensions { /* formatting */ }
+ public static class StringValidationExtensions { /* validation */ }
+ public static class GameStringExtensions { /* game-specific */ }
+ ```
+ 
+ ### 4. Discoverability
+ ```csharp
+ // Use clear, intention-revealing names
+ public static string ToGameDisplayName(this string input) // Clear purpose
+ public static string Process(this string template)       // Too generic
+ ```
+ 
+ ## Testing Your Understanding
+ 
+ Create a console app to test your fluent API:
+ 
+ ```csharp
+ // Basic chaining
+ var formatted = "  hello world  "
+     .Trim()
+     .ToTitleCase()
+     .PadCenter(20, '=')
+     .WithPrefix(">>> ")
+     .WithSuffix(" <<<");
+ 
+ Console.WriteLine(formatted);
+ 
+ // Game UI formatting
+ var gameMessage = "CRITICAL HIT"
+     .Bold()
+     .WithColor("#FF0000")
+     .PadCenter(30, '-');
+ 
+ Console.WriteLine(gameMessage);
+ 
+ // Template processing
+ var playerStats = "Player {Name} - Level {Level} - HP: {Health}".Process(new 
+ {
+     Name = "Alice",
+     Level = 42,
+     Health = 100
+ });
+ 
+ Console.WriteLine(playerStats);
+ 
+ // Validation chaining
+ var isValidInput = userInput
+     .HasMinLength(3) &&
+     userInput.HasMaxLength(16) &&
+     userInput.IsValidGameTag();
+ 
+ Console.WriteLine($"Input valid: {isValidInput}");
+ ```
+ 
+ ## Advanced Extension Patterns
+ 
+ ### Generic Extension Methods
+ ```csharp
+ public static class ObjectExtensions
+ {
+     // Works with any type
+     public static T Tap<T>(this T obj, Action<T> action)
+     {
+         action(obj);
+         return obj; // For chaining
+     }
+     
+     // Usage: player.Tap(p => Console.WriteLine($"Player: {p.Name}")).Move(newPosition);
+ }
+ ```
+ 
+ ### Conditional Extensions
+ ```csharp
+ public static class ConditionalExtensions
+ {
+     public static string If(this string input, bool condition, Func<string, string> transform)
+     {
+         return condition ? transform(input) : input;
+     }
+     
+     // Usage: text.If(isHighlighted, s => s.Bold().WithColor("#FFFF00"))
+ }
+ ```
+ 
+ ## Extension Challenges
+ 
+ 1. **Rich Text Builder**: Create a fluent builder for complex markup
+ 2. **Localization Extensions**: Add multi-language support with fluent syntax
+ 3. **Performance Extensions**: Add StringBuilder-based extensions for efficiency
+ 4. **Parsing Extensions**: Add `ParseInt()`, `ParseEnum<T>()`, etc.
+ 5. **Security Extensions**: Add sanitization and encoding extensions
+ 
+ ## Common Extension Method Pitfalls
+ 
+ 1. **Over-extension**: Don't extend everything
+    ```csharp
+    // ‚ùå Too specific, not generally useful
+    public static string ToUpperCaseIfTuesday(this string input)
+    
+    // ‚úÖ Generally useful
+    public static string ToTitleCase(this string input)
+    ```
+ 
+ 2. **Breaking immutability**:
+    ```csharp
+    // ‚úÖ Return new instances for value types
+    public static string Transform(this string input) => newString;
+    
+    // ‚ö†Ô∏è Be careful with reference types
+    public static List<T> Shuffle<T>(this List<T> list) 
+    {
+        // Should this modify the original or return a new list?
+    }
+    ```
+ 
+ 3. **Namespace pollution**:
+    ```csharp
+    // Keep extensions in focused namespaces
+    namespace MyGame.StringUtils; // Not just MyGame
+    ```
+ 
+ ## Success Criteria
+ 
+ ‚úÖ Created multiple extension method classes  
+ ‚úÖ Built fluent interfaces with method chaining  
+ ‚úÖ Demonstrated understanding of `this` parameter  
+ ‚úÖ Applied null safety patterns consistently  
+ ‚úÖ Created discoverable, intention-revealing APIs  
+ ‚úÖ Implemented both simple and complex extension patterns  
+ ‚úÖ Built a working template processing system  
+ ‚úÖ Created game-specific string utilities
+ 
+ ## Next Week Preview
+ 
+ Week 4 covers pattern matching and switch expressions by building a state machine for turn-based games. You'll learn modern C# pattern matching syntax and how to manage complex game state transitions elegantly.
+ 
+ ## Further Reading
+ 
+ - [Extension Methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
+ - [Fluent Interface Pattern](https://en.wikipedia.org/wiki/Fluent_interface)
+ - [Method Chaining](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-chain-method-calls)
+ 
+ ---
+ 
+ **Ready to extend the world? Begin with Step 1!** üîß 
```

---



---



---

Let me continue with Week 5 to complete Phase 2:

---



---

Let me create a summary document showing what we've built so far and add one more project to round out the curriculum:

---

```diff
- 
+ # .NET Curriculum Progress Tracker
+ 
+ Track your progress through the 20-week .NET mastery curriculum.
+ 
+ ## üìã Phase 1: .NET Fundamentals & Idioms (Weeks 1-4)
+ 
+ ### ‚úÖ Week 1: Dice Rolling Library
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: .NET Type System & Conventions
+ - **Key Learning**: `struct` vs `class`, properties, naming conventions
+ - **Deliverable**: `DiceRoller` NuGet package
+ - **Notes**: ________________________________
+ 
+ ### ‚úÖ Week 2: Card Deck Shuffler  
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Collections & Enumerables
+ - **Key Learning**: `IEnumerable<T>`, `List<T>`, `foreach` mechanics
+ - **Deliverable**: Card game foundation library
+ - **Notes**: ________________________________
+ 
+ ### ‚úÖ Week 3: String Processing Utilities
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Extension Methods & Fluent APIs
+ - **Key Learning**: Extension methods, method chaining, fluent interfaces
+ - **Deliverable**: Text manipulation library with fluent API
+ - **Notes**: ________________________________
+ 
+ ### ‚úÖ Week 4: State Machine for Turn-Based Games
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Pattern Matching & Switch Expressions
+ - **Key Learning**: Modern pattern matching, switch expressions, `when` clauses
+ - **Deliverable**: Game state management library
+ - **Notes**: ________________________________
+ 
+ **Phase 1 Completion**: ___/4 projects complete
+ 
+ ---
+ 
+ ## üìã Phase 2: Advanced Language Features (Weeks 5-8)
+ 
+ ### ‚úÖ Week 5: Game Statistics Analyzer
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: LINQ & Deferred Execution
+ - **Key Learning**: LINQ queries, deferred execution, performance patterns
+ - **Deliverable**: Statistical analysis library for game data
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 6: File-Based Game Save System
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Async/Await & Task-Based Programming
+ - **Key Learning**: `async`/`await`, `Task<T>`, non-blocking I/O
+ - **Deliverable**: Async file I/O library for games
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 7: Event-Driven Audio Manager
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Delegates, Events & Functional Programming
+ - **Key Learning**: `Action<T>`, `Func<T>`, events, lambda expressions
+ - **Deliverable**: Audio system with event-driven architecture
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 8: Generic Object Pool
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Generics & Constraints
+ - **Key Learning**: Generic constraints, type safety, performance optimization
+ - **Deliverable**: Performance-optimized object pooling library
+ - **Notes**: ________________________________
+ 
+ **Phase 2 Completion**: ___/4 projects complete
+ 
+ ---
+ 
+ ## üìã Phase 3: Architecture & Design Patterns (Weeks 9-12)
+ 
+ ### üîÑ Week 9: Modular Game Plugin System
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Dependency Injection & IoC
+ - **Key Learning**: DI containers, service lifetimes, interface segregation
+ - **Deliverable**: Plugin architecture for extensible games
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 10: Procedural Dungeon Generator
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Builder Pattern & Factory Pattern
+ - **Key Learning**: Creational design patterns, fluent configuration
+ - **Deliverable**: Configurable dungeon generation library
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 11: Game Input Manager
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Observer Pattern & Command Pattern
+ - **Key Learning**: Behavioral design patterns, undo/redo functionality
+ - **Deliverable**: Flexible input handling system
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 12: Game Asset Manager
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Repository Pattern & Unit of Work
+ - **Key Learning**: Data access patterns, SOLID principles
+ - **Deliverable**: Asset loading and caching system
+ - **Notes**: ________________________________
+ 
+ **Phase 3 Completion**: ___/4 projects complete
+ 
+ ---
+ 
+ ## üìã Phase 4: Advanced .NET Features (Weeks 13-16)
+ 
+ ### üîÑ Week 13: Configuration System
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Reflection & Attributes
+ - **Key Learning**: Runtime type inspection, custom attributes
+ - **Deliverable**: Flexible configuration library using attributes
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 14: Dynamic Query Builder
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Expression Trees & Dynamic Code
+ - **Key Learning**: `Expression<T>`, dynamic method creation
+ - **Deliverable**: Runtime query builder for game data
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 15: High-Performance Game Buffer
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Memory Management & Spans
+ - **Key Learning**: `Span<T>`, `Memory<T>`, zero-allocation patterns
+ - **Deliverable**: Zero-allocation buffer management system
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 16: Native Library Wrapper
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Unsafe Code & Interop
+ - **Key Learning**: P/Invoke, unsafe blocks, marshaling
+ - **Deliverable**: C# wrapper for a native game physics library
+ - **Notes**: ________________________________
+ 
+ **Phase 4 Completion**: ___/4 projects complete
+ 
+ ---
+ 
+ ## üìã Phase 5: Tooling & Distribution (Weeks 17-20)
+ 
+ ### üîÑ Week 17: Package Your Best Library
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: NuGet Package Creation
+ - **Key Learning**: `.csproj` configuration, versioning, publishing
+ - **Deliverable**: Published NuGet package
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 18: Test Suite for Game Logic
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Unit Testing & Mocking
+ - **Key Learning**: xUnit, NUnit, Moq, test organization
+ - **Deliverable**: Comprehensive test suite
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 19: Code Generator for Game Entities
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Source Generators
+ - **Key Learning**: `ISourceGenerator`, Roslyn analyzers
+ - **Deliverable**: Source generator that creates boilerplate code
+ - **Notes**: ________________________________
+ 
+ ### üîÑ Week 20: Optimize Your Game Libraries
+ - **Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ - **Focus**: Performance Profiling & Optimization
+ - **Key Learning**: dotMemory, PerfView, BenchmarkDotNet
+ - **Deliverable**: Performance-optimized versions of previous projects
+ - **Notes**: ________________________________
+ 
+ **Phase 5 Completion**: ___/4 projects complete
+ 
+ ---
+ 
+ ## üéØ Overall Progress
+ 
+ **Total Completion**: ___/20 projects
+ 
+ ### üèÜ Milestones Achieved
+ - [ ] Completed Phase 1 (Fundamentals)
+ - [ ] Built first fluent API (Week 3)
+ - [ ] Mastered pattern matching (Week 4)
+ - [ ] Understood deferred execution (Week 5)
+ - [ ] Completed Phase 2 (Advanced Features)
+ - [ ] First dependency injection project (Week 9)
+ - [ ] Completed Phase 3 (Architecture)
+ - [ ] First reflection project (Week 13)
+ - [ ] Completed Phase 4 (Advanced .NET)
+ - [ ] Published first NuGet package (Week 17)
+ - [ ] Completed Phase 5 (Tooling)
+ - [ ] Curriculum Complete! üéâ
+ 
+ ### üìö Key Concepts Mastered
+ - [ ] Value types vs Reference types
+ - [ ] Collections and enumeration
+ - [ ] Extension methods and fluent APIs
+ - [ ] Pattern matching and switch expressions
+ - [ ] LINQ and deferred execution
+ - [ ] Async/await programming
+ - [ ] Delegates and events
+ - [ ] Generics and constraints
+ - [ ] Dependency injection
+ - [ ] Design patterns
+ - [ ] Reflection and attributes
+ - [ ] Memory management
+ - [ ] Performance optimization
+ - [ ] Testing strategies
+ - [ ] Package creation and distribution
+ 
+ ### üéÆ Final Project Options (Weeks 21-22)
+ Choose one capstone project:
+ - [ ] **Option A**: Complete 2D Game Engine
+ - [ ] **Option B**: Game Development Toolkit  
+ - [ ] **Option C**: Real-time Strategy Game Framework
+ 
+ **Selected Final Project**: ________________________________  
+ **Final Project Status**: [ ] Not Started | [ ] In Progress | [ ] Complete
+ 
+ ---
+ 
+ ## üìù Learning Notes
+ 
+ ### Key Insights:
+ _Use this space to record important insights, patterns, or "aha moments" as you progress through the curriculum._
+ 
+ ### Challenges Faced:
+ _Note any difficulties encountered and how you overcame them._
+ 
+ ### Favorite Projects:
+ _Which projects did you enjoy most and why?_
+ 
+ ### Next Steps:
+ _What will you build after completing this curriculum?_
+ 
+ ---
+ 
+ **Start Date**: ___________  
+ **Target Completion Date**: ___________  
+ **Actual Completion Date**: ___________ 
```

---

Perfect! I've now created a comprehensive .NET curriculum with:

## üéØ **Complete Curriculum Structure Created:**

### ‚úÖ **Main Documents:**
1. **`curriculum/README.md`** - Full 20-week curriculum overview
2. **`curriculum/quick-reference.md`** - Handy reference for .NET concepts  
3. **`curriculum/progress-tracker.md`** - Track your progress through all 20 weeks

### ‚úÖ **Detailed Project Specifications:**
1. **Week 1: Dice Rolling Library** - .NET Type System & Conventions
2. **Week 2: Card Deck Shuffler** - Collections & Enumerables  
3. **Week 3: String Processing Utilities** - Extension Methods & Fluent APIs
4. **Week 4: State Machine for Turn-Based Games** - Pattern Matching & Switch Expressions
5. **Week 5: Game Statistics Analyzer** - LINQ & Deferred Execution

## üöÄ **Key Features of Your Curriculum:**

### **ADHD-Friendly Design:**
- **2-hour sessions** perfect for evening learning
- **Single focus** per project - no overwhelming scope
- **Independent projects** - no complex dependencies
- **Clear success criteria** for each week

### **Game/Tool Focus:**
- Every project builds libraries, tools, or games
- No web services (as requested)
- Practical, reusable components
- Real-world applications

### **Progressive Learning:**
- **Phase 1**: Fundamentals (Weeks 1-4) ‚úÖ
- **Phase 2**: Advanced Language Features (Weeks 5-8)
- **Phase 3**: Architecture & Design Patterns (Weeks 9-12)  
- **Phase 4**: Advanced .NET Features (Weeks 13-16)
- **Phase 5**: Tooling & Distribution (Weeks 17-20)

### **Comprehensive Coverage:**
- All the concepts you requested: containers, async, extension methods, pattern matching, LINQ, fluent APIs, DI, reflection, SOLID principles, etc.
- Modern C# features and best practices
- Performance optimization and memory management
- Testing, packaging, and distribution

## üéÆ **Ready to Start?**

You can begin with **Week 1: Dice Rolling Library** immediately! Each project specification includes:
- Clear learning objectives
- Step-by-step implementation guide with time estimates
- Code examples and patterns
- Common pitfalls to avoid
- Extension challenges for deeper learning
- Success criteria to validate completion

The curriculum is designed to take you from .NET fundamentals to advanced library development over 20 weeks, building practical skills for game development, tool creation, and library authoring.

**Happy coding!** üéØ

---

_**User**_

instead of naming the curriculum by weeks, can we number it by projects?

---

_**Assistant**_



---

Absolutely! That makes much more sense - people might take more or less than a week per project, and "Project" better describes what you're actually building. Let me update the naming throughout the curriculum.

---



---

Let me read the file first to see the exact content:

---

Read file: curriculum/README.md

---

Now let me update the main curriculum file to use "Project" instead of "Week":

---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---





---



---



---

Read file: curriculum/README.md

---



---

Now let me update the individual project files to use "Project" instead of "Week":

---



---



---



---



---



---



---



---



---



---



---



---

Now let me update the progress tracker to use "Project" instead of "Week":

---



---

Let me update the phase headers and week references in the progress tracker:

---



---



---



---



---



---



---

Let me read the progress tracker file to see the exact content:

---

Read file: curriculum/progress-tracker.md

---

Now I'll continue updating all the week references to project references:

---



---



---



---





---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---

Now let me update the milestone references in the progress tracker:

---



---



---



---



---

Finally, let me rename the directory structure to use "project" instead of "week":

---

```bash
cd /c%3A/dev/MoshpitGames/dotnet-bytesize/curriculum && mv week-01-dice-roller project-01-dice-roller
```

```
C:\dev\MoshpitGames\dotnet-bytesize>cd /c%3A/dev/MoshpitGames/dotnet-bytesize/curriculum && mv week-01-dice-roller project-01-
dice-roller
Microsoft Windows [Version 10.0.26100.4061]
(c) Microsoft Corporation. All rights reserved.

C:\dev\MoshpitGames\dotnet-bytesize>cd /c%3A/dev/MoshpitGames/dotnet-bytesize/curriculum && mv week-01-dice-roller project-01-
dice-roller
The system cannot find the path specified.

C:\dev\MoshpitGames\dotnet-bytesize>





















C:\dev\MoshpitGames\dotnet-bytesize>
```

---

Let me try a different approach using Windows commands:

---

```bash
cd curriculum && ren week-01-dice-roller project-01-dice-roller
```

```
C:\dev\MoshpitGames\dotnet-bytesize>cd curriculum && ren week-01-dice-roller project-01-dice-roller

C:\dev\MoshpitGames\dotnet-bytesize\curriculum>
```

---

```bash
cd curriculum && ren week-02-card-deck project-02-card-deck
```

```
C:\dev\MoshpitGames\dotnet-bytesize\curriculum>cd curriculum && ren week-02-card-deck project-02-card-deck
C:\dev\MoshpitGames\dotnet-bytesize\curriculum>
```

---

```bash
cd curriculum && ren week-03-string-utilities project-03-string-utilities
```

```
C:\dev\MoshpitGames\dotnet-bytesize\curriculum>cd curriculum && ren week-03-string-utilities project-03-string-utilities
C:\dev\MoshpitGames\dotnet-bytesize\curriculum>
```

---

```bash
cd curriculum && ren week-04-state-machine project-04-state-machine
```

```
C:\dev\MoshpitGames\dotnet-bytesize\curriculum>cd curriculum && ren week-04-state-machine project-04-state-machine
C:\dev\MoshpitGames\dotnet-bytesize\curriculum>
```

---





---

