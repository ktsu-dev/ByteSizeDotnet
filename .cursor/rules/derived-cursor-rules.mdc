---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## TECH STACK

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   The curriculum should contain a dedicated page similar to the quick reference for the Microsoft design and style guidelines for .NET libraries and applications.
*   The curriculum should have a glossary of terms too.
*   Update the main README to guide users to the quick reference, progress tracker, and design guidelines.

## CODING STANDARDS

## WORKFLOW & RELEASE RULES

## DEBUGGING

## BEST PRACTICES & GUIDELINES

When creating .NET learning curricula, prioritize the following:

*   **Focus:** Emphasize building libraries, tools, and games over web services.
*   **Time Commitment:** Design projects suitable for approximately 2 hours of evening work.
*   **ADHD Considerations:** Create small, approachable projects with a clear, single focus to facilitate learning and maintain engagement.
*   **Programming Fundamentals:** Minimize time spent on basic programming constructs (conditions, flow control, variables, types, methods). Instead, focus on their .NET-specific expressions and nomenclature.
*   **Advanced Concepts:** Prioritize topics like:
    *   Containers
    *   Async programming
    *   Extension methods
    *   Pattern matching
    *   Enumerables and deferred execution
    *   LINQ
    *   Fluent APIs
    *   Dependency Injection
    *   NuGet
    *   Reflection
    *   SOLID and DRY principles
    *   Lambdas
    *   Predicates
    *   Selectors
    *   Callbacks
*   **Curriculum Structure:** Structure concepts to build upon each other logically. Projects do not need to be related to each other thematically; unrelated projects may be preferable to minimize contextual distractions.

*   **Stack vs Heap Allocation:** When explaining value vs. reference semantics in the quick reference, always explain stack vs heap allocation *before* explaining value vs reference semantics. This provides necessary context.

*   **Terminology Reference Table:** The quick reference guide should include a table relating common .NET names (class, struct, method, parameter, property, field) to generic programming terms and their counterparts in other languages (e.g., Java, Python, JavaScript, C++, Go, Rust). This table should cover core types, code organization, modifiers, and advanced features and modern patterns. It should also include a section explaining key differences, such as properties being unique to .NET, struct differences between .NET and C++ struct differences between .NET and C++, namespace vs. package concepts, event system specifics, and LINQ as a unique .NET feature. Position the table after the naming conventions section in the quick reference. The language translation guide should mention records, containers, lambdas objects, built in types, tuples etc.

*   **Documentation Links:** The quick reference should provide quick links to Microsoft documentation for each topic. **The documents should always provide quick links to the Microsoft documentation. Reading the docs should be a fundamental theme of the curriculum.** Documentation links should be added throughout the curriculum, including in the main curriculum README and individual project READMEs, organized into logical categories. This reinforces documentation reading as a core skill.

*   The curriculum should contain a dedicated page similar to the quick reference for the Microsoft design and style guidelines for .NET libraries and applications.

*   Ensure the curriculum covers lambdas, predicates, selectors, callbacks, records, primary constructors, and other relevant modern .NET features.

*   **Document Structure & Layout:** The project should adhere to the following document structure:

    *   **README.md:** Streamlined high-level curriculum overview, learning philosophy, quick navigation to other documents, and a "Getting started" section (approximately 200 lines). **The README is now the full implementation guide after merging the project guide content.**
    *   **curriculum-details.md:** Detailed project information, phase-by-phase breakdown, learning objectives, and deliverables (approximately 400 lines).
    *   **microsoft-design-guidelines.md:** Keep as standalone file with current comprehensive content (approximately 700 lines). Add curriculum cross-references (which projects use which guidelines) and maybe add a "Quick Start" section at the top for immediate needs.
    *   **language-essentials.md:** Core .NET concepts needed for the curriculum, essential syntax and patterns, and cross-references to full reference docs (approximately 300 lines). Heavy cross-references to Microsoft guidelines. "See design-guidelines.md for the full story" type callouts.
    *   **reference/:** A directory containing focused reference files:
        *   **reference/glossary.md:** Term definitions (approximately 300 lines - current size).
        *   **reference/language-comparison.md:** Language mappings from the quick-reference (approximately 400 lines).
        *   **reference/quick-syntax.md:** Syntax examples (approximately 300 lines).
    *   **progress-tracker.md:** Current progress tracking (approximately 300 lines). Add "Guidelines Checklist" for each project and links to specific guideline sections.

    This structure promotes shorter, focused documents with a clear purpose for each file, progressive disclosure of information, and easy maintenance.

    When restructuring documents, consider these principles:
    *   **Minimize Redundancy:** Remove duplicate content, especially between naming conventions in multiple files.
    *   **Establish Clear Hierarchies:** Present basic concepts before advanced topics.
    *   **Incorporate Cross-References:** Link related concepts to improve understanding.
    *   **Separate Concerns:** Distinguish between reference material and curriculum content.
    *   **Maintain Consistent Formatting:** Ensure uniform formatting across all documents.
    *   **Utilize Headers Effectively:** Employ headers for clear navigation.
    *   **Include Tables of Contents:** Add tables of contents to longer documents.
    *   **Use Visual Indicators:** Use icons or formatting to differentiate content types.
    *   **Provide Quick Navigation:** Include a quick navigation section in the README.
    *   **Differentiate "What You Need" vs "Reference":** Clearly distinguish between essential information and reference material.
    *   **Optimize for Search:** Use search-friendly headings and keywords.
    *   **Employ Progressive Disclosure:** Present summaries first, with details available upon request.

*   **README Content:** The README must have the following:
    *   High-level curriculum overview
    *   A prominent "Essential Resources" section highlighting Microsoft guidelines
    *   Quick navigation with clear callouts to design guidelines
    *   A "Getting started" workflow that references guidelines early

The "Essential Resources" section should be formatted as follows:

```markdown
## Essential Resources Before You Start
1. üìè **[Microsoft Design Guidelines](microsoft-design-guidelines.md)** - The foundation for all .NET code
2. üìö **[Curriculum Details](curriculum-details.md)** - What you'll build (detailed project breakdown)
3. üß† **[Language Essentials](language-essentials.md)** - Core .NET concepts you need to know
4. üéØ **[Progress Tracker](progress-tracker.md)** - Track your journey through the curriculum
```
The README should also contain these "Quick Reference Resources":

```markdown
## Quick Reference Resources

5. üìñ **[Reference Directory](reference/)** - Deep-dive references when you need them
   - **[Glossary](reference/glossary.md)** - .NET terminology explained
   - **[Language Comparison](reference/language-comparison.md)** - How .NET maps to other languages
   - **[Quick Syntax](reference/quick-syntax.md)** - Handy syntax reference
```

The README should also have a "Curriculum Overview" section, with the following content:

```markdown
## Curriculum Overview

### Phase 1: .NET Fundamentals & Idioms (Projects 1-4)
**Focus**: Core language features and conventions

1. **Dice Rolling Library** - Type system & naming conventions
2. **Card Deck Shuffler** - Collections & enumerables
3. **String Processing Utilities** - Extension methods & fluent APIs
4. **State Machine** - Pattern matching & switch expressions

### Phase 2: Advanced Language Features (Projects 5-8)
**Focus**: Modern C# capabilities

5. **Game Statistics Analyzer** - LINQ & deferred execution
6. **File-Based Game Save System** - Async/await programming
7. **Event-Driven Audio Manager** - Delegates, events & functional programming
8. **Generic Object Pool** - Generics & constraints

### Phase 3: Architecture & Design Patterns (Projects 9-12)
**Focus**: Software design principles

9. **Modular Game Plugin System** - Dependency injection & IoC
10. **Procedural Dungeon Generator** - Builder & factory patterns
11. **Game Input Manager** - Observer & command patterns
12. **Game Asset Manager** - Repository pattern & unit of work

### Phase 4: Advanced .NET Features (Projects 13-16)
**Focus**: Runtime and performance features

13. **Configuration System** - Reflection & attributes
14. **Dynamic Query Builder** - Expression trees & dynamic code
15. **High-Performance Game Buffer** - Memory management & spans
16. **Native Library Wrapper** - Unsafe code & interop

### Phase 5: Tooling & Distribution (Projects 17-20)
**Focus**: Professional development practices

17. **Package Your Best Library** - NuGet package creation
18. **Test Suite for Game Logic** - Unit testing & mocking
19. **Code Generator for Game Entities** - Source generators
20. **Optimize Your Game Libraries** - Performance profiling & optimization
```

The README should also have a "Getting Started" section, with the following content:

```markdown
## Getting Started

### 1. **Read the Foundation** üìè
Start with [Microsoft Design Guidelines](microsoft-design-guidelines.md) to understand .NET conventions and best practices.

### 2. **Plan Your Journey** üìö
Review [Curriculum Details](curriculum-details.md) to understand what you'll build and learn in each project.

### 3. **Set Up Tracking** üéØ
Use the [Progress Tracker](progress-tracker.md) to monitor your advancement and reflect on learnings.

### 4. **Reference as Needed** üìñ
Bookmark the [Reference Directory](reference/) for quick lookups during development.
```

The README should also have a "Final Projects" section, with the following content:

```markdown
## Final Projects (Choose One)

After completing the 20 core projects, choose a capstone project:

- **Game Engine Architecture** - Combine multiple patterns into a cohesive game engine
- **Development Toolchain** - Build a complete development workflow with CI/CD
- **Performance-Critical Library** - Create a highly optimized library using advanced .NET features
```

The README should also have a "Project Structure" section, with the following content:

```markdown
Each project folder contains:
- **README.md** - Project overview and requirements
- **src/** - Implementation code
- **tests/** - Unit tests (when applicable)
- **docs/** - Project-specific documentation
```

The README should also have a "Contributing" section, with the following content:

```markdown
## Contributing

This curriculum is open for contributions! See individual project folders for specific contribution guidelines.
```

The README should also have a "Learning Support" section, with the following content:

```markdown
## Learning Support

- **Microsoft Guidelines Integration** - Each project explicitly references relevant design guidelines
- **Cross-References** - Documents link to related concepts across the curriculum
- **Progressive Disclosure** - Start simple, reference deeper material as needed
- **Practical Focus** - Every concept is taught through building real libraries and tools
```

*   **Unit Testing Framework:** All testing should be done with MSTest, not xUnit or nUnit etc.

*   For the first project in the curriculum, guide the user to create the directory structure and set up the projects themselves. For subsequent projects, provide template projects in the correct layout for them.

*   Project 2 onward: provide template projects in the correct layout for them (only .sln and .csproj files). **All projects from project 2 onwards should follow the same directory layout.**

*   **Project Directory Layout**:
    *   Project 1: User manually creates the directory structure and sets up the projects.
    *   Projects 2-20: Follow the same directory layout. The solution file and all project folders (e.g., Core, App, Tests) reside in the project's root directory, *not* within a `src` subdirectory.

*   **Empty Directories:** All empty `docs` and `tests` directories should be removed from the project structure. These directories will not be included in template projects.

*   **Comprehensive README Files:** The README files for each project must be the comprehensive guide for implementing the project and learning the desired concepts. Separate project guides should be used as reference when updating the READMEs and then removed. All READMEs should follow a similar format and structure and be comprehensive.

*   **README Consistency Check:** Ensure that the README files for projects 7-20 are consistent with the format and structure of the README files in earlier projects (1-6). The README files for projects 7-19 are currently not in line with the comprehensive format established in projects 1-6 and need to be updated. These projects are missing detailed implementation guides, "Testing Your Understanding" sections, "Extension Challenges", "Common Pitfalls & Solutions", comprehensive code examples, and contain shorter, less educational content. Project 18's README is currently empty and requires immediate attention.

*   **Projects Layout Analysis:**
    *   Complete Projects (with Core/App/Tests): Projects 3, 4, 5, 7 - Full three-tier structure
    *   Partial Projects (solution + core only): Projects 6, 8, 9, 13, 19, 20 - Have Core libraries and solutions
    *   Minimal Projects (solution + README only): Projects 10, 11, 12, 14, 17, 18 - Just solution files and documentation
    *   Documentation Only: Project 15, 16 - Currently has only README

*   **.gitignore Configuration:** The root directory should contain a comprehensive `.gitignore` file tailored for .NET development. This file should exclude build artifacts, temporary files, IDE-specific files, and other files that should not be tracked in version control. The `.gitignore` file should include the following entries:

```
# .NET Core build outputs
bin/
obj/
out/

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio temporary files, build results, and
# files generated by popular Visual Studio add-ons.
*.user
*.suo
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these files may be public
*.azurePubxml

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
CConversionReportData_*.txt
CConversionReportOutput_*.txt

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
.idea/

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# Mono auto generated files
mono_crash.*

# Windows image file caches
Thumbs.db
ehthumbs.db

# Folder config file
Desktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Mac
.DS_Store

# Windows Installer files
*.cab
*.msi
*.msm
*.msp

# Windows shortcuts
*.lnk

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt

# Others
*.Cache
ClientBin/
[Ss]tyle[Cc]op.*
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.pfx
*.publishsettings
orleans.codegen.cs

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm

# SQL Server files
*.mdf
*.ldf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# JetBrains Rider
.idea/
*.sln.iml

# CodeRush
.cr/

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Obsidian workspace (keep existing entry)
.obsidian/workspace.json

```

*   **Project Directory Layout**:
    *   Project 1: User manually creates the directory structure and sets up the projects.
    *   Projects 2-20: Follow the same directory layout. The solution file and all project folders (e.g., Core, App, Tests) reside in the project's root directory, *not* within a `src` subdirectory.
        *   For projects where the intention is to make a library, include an App project to demo the functionality.

*   **Empty Directories:** All empty `docs` and `tests` directories should be removed from the project structure. These directories will not be included in template projects.

*   **Comprehensive README Files:** The README files for each project must be the comprehensive guide for implementing the project and learning the desired concepts. Separate project guides should be used as reference when updating the READMEs and then removed. All READMEs should follow a similar format and structure and be comprehensive.

*   **README Consistency Check:** Ensure that the README files for projects 7-20 are consistent with the format and structure of the README files in earlier projects (1-6). The README files for projects 7-19 are currently not in line with the comprehensive format established in projects 1-6 and need to be updated. These projects are missing detailed implementation guides, "Testing Your Understanding" sections, "Extension Challenges", "Common Pitfalls & Solutions", comprehensive code examples, and contain shorter, less educational content. Project 18's README is currently empty and requires immediate attention.

*   **Projects Layout Analysis:**
    *   Complete Projects (with Core/App/Tests): Projects 3, 4, 5, 7 - Full three-tier structure
    *   Library Projects (Core + Tests + Solution): Projects 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    *   *Projects 6, 8, 9, 13, 19, 20 - Have Core libraries and solutions*
    *   *Projects 10, 11, 12, 14, 17, 18 - Just solution files and documentation*
    *   Minimal Projects (solution + README only): Projects 10, 11, 12, 14, 16, 17, 18 - Just solution files and documentation
    *   Documentation Only: Project 15, 16 - Currently has only README
        *   The above lists are now deprecated as all projects should now fit the complete projects structure.